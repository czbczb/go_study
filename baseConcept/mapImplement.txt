哈希表（buckets）：一堆桶
来了一个{k1, v1}----通过hash func处理key，得到一个hash值
使用hash值从m个桶中选择一个，桶的编号[0,m-1]
  选择桶的2种方法：
  1、取模法   桶编号 =  hash值 % m
  2、与运算   hash值 & (m - 1)
    注意：要使运算结果不出现empty bucket
    必须保证m必须是2的整数次幂 这样就可以保证m的二进制表示就会只有一位为1，m-1的二进制表示一定是低于这一位的所有位均为1

问题：hash冲突（同一个桶被多次选中）
  解决方案2种：
    假设前提：2号桶被占用
    1、开放地址法：选择2号桶后面没有被占用的桶，查找时会先找2号桶，再比较key，key不同，则遍历后面的桶，直到key相等，或者遇到空桶（key不存在）
    2、拉链法：在2号桶后面创建一下新桶，在查找key时还是会先找到2号桶，比较key不相等，所以顺着链表往后查找

    hash冲突会影响hash表的读写效率，

问题：如何保证读写效率
    1、选择散列均匀的hash函数，减少hash冲突的发生
    2、适时对hash表扩容

问题：扩容的判断依据
    load factory = count / m     
    渐进式扩容（将hash表扩容的时间，分摊到多次hash表操作的方式）
    好处：
      避免一次行扩容带来的性能瞬时抖动
    oldbuckets（旧桶的位置），
    nevacuate（下一个需要歉意的旧桶编号=即进度）

golang中的map底层是hmap

问题：map使用的桶的结构：bmap

溢出桶：使用的桶的数量大于2^4，就表示使用溢出桶的几率比较大，就会分配2^(b-4)个溢出桶备用
      溢出桶和常规桶的内存是连续的

扩容规则：
  count / (2^B) > 6.5------> 翻倍扩容， 分配新的数目是旧桶的2倍

  loadFactor没有超标，但是noverflow较多

  noverflow的多判断依据：
    1、当B(常规桶的数量) <= 2^15: 且使用的溢出桶noveflow >= 2^B
    2、B > 15, 使用溢出桶noverflow > 2^15

情景：
  桶的负载因子没有超过上限值，但是使用了大量的溢出桶：很多健值对被删除的情况下会出现


  等量扩容的意义：
    同样数目的健值对，迁移到新桶中能够排列的更加紧凑，从而减少溢出桶的使用





  




